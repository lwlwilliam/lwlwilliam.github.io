---
title: P2P 简介
layout: post
categories: [计算机网络]
keywords: p2p
---

P2P 对永久在线的服务器依赖极小，甚至可以完全不依赖；相反，（只要）一对被称为`peer`的间歇性连接的主机直接通信。主机并不属于服务提供商，它们是由用户控制的台式机和笔记本。

有三种非常符合 P2P 设计的程序。第一种是文件分发，将文件从一个源分发到大量的主机那里，例如 BitTorrent 系统属于这种；第二种是分布式数据库，这里涉及到 DHT(Distributed Hash Table)；最后是 Skype，非常成功的 P2P 网络电话应用。

### P2P 文件分发

文件分发就是将一个大文件从一台服务器分发到大量主机上。这个文件可能是新版的 Linux、操作系统或程序的补丁、MP3 音频文件或者 MPEG 视频文件。如果是客户端-服务端的文件分发，服务器必须将文件发送到每一台主机——造成服务器的巨大负担，消耗大量的服务器带宽。在 P2P 文件分发中，每台主机都可以重新分发它已经接收的文件的任意部分到其它主机，从而可以帮助服务器分发。最流行的 P2P 文件分发协议是 BitTorrent（2009 年）。

##### BitTorrent

BitTorrent 是一个流行的文件分发 P2P 协议。在 BitTorrent 中，所有参与文件分发的主机集合称为`torrent`。在 torrent 里的主机都从另外的主机中下载相同大小的文件块，典型的块大小是 256 KB。当主机首次加入 torrent 时，它是没有文件块的。随着时间的推移，它会慢慢累积越来越多的块。在下载块的同时，它也会上传块给其它主机。一旦主机下载完整个文件，它可能（自私地）离开 torrent，或者仍然（无私地）留在 torrent 中给其它主机上传文件块。另外，任何的主机都可能在任意时间离开 torrent，即使只下载了部分的块，可能迟点再重新加入 torrent。

每个 torrent 都有一个称为`tracker`的基础节点。当主机加入 torrent 时，它会将自己注册到 tracker 中，然后定时通知 tracker 它还在 torrent 中。在这种方式中，tracker 会追踪每个加入到 torrent 中的主机。一个 torrent 在持续的时间中，可能主机数会少于 10，也可能多于 1000。

下面是一个示例。一个叫做 Alice 的主机加入了 torrent，tracker 会从所有的主机中随机选择一批（例如是 50 个）主机出来，把这些主机的 IP 都发送给 Alice。Alice 在拿到这些主机之后，会尝试跟所有的主机并发地建立 TCP 连接。我们把跟 Alice 成功建立连接的主机称为`neighboring peer`（邻近主机）。随着时间的推移，一些主机可能会离开，另外的主机（那最初的 50 个以外的）会尝试跟 Alice 建立 TCP 连接。因此，一个主机的邻近主机数量会随着时间而有所变化。

在任意时刻，每个主机都会有部分文件块，不同的主机会有不同的文件块。Alice 会定时询问它的邻近主机（通过 TCP 连接）所持有的文件块列表。如果 Alice 有 L 个不同的 neighbors，它就会获得 L 个文件块列表。Alice 就可以根据这些来请求（再次通过 TCP 连接）它所没有的文件块。

因此在任意时刻，Alice 都拥有一部分文件块，并且知道它的 neighbors 拥有什么文件块。Alice 有两个重要的决定需要做。首先，它应该先向它的 neighbors 请求哪些块？第二，它应该向哪一个 neighbors 请求文件块？决定请求哪些块时，Alice 使用一个叫`rarest first`（最少优先）的技巧。这个方法用来决定它所没有的块中哪个在 neighbors 中是最少的（也就是说在 neighbors 中重复次数最少的块）。在这个方式中，最稀少的块会最快分发，目的是使每个块在 torrent 中分布平均。

为了决定应该响应哪个请求，BitTorrent 使用了一个聪明的交换算法。基本的方法就是 Alice 优先考虑当前以最高速率提供数据的 neighbors。特别是，Alice 会持续地检测从每个 neighbors 接收数据的速率，然后选择四台提供数据最快的主机。然后，再通过发送文件块到这四台主机进行数据互换。每隔 10 秒，它都会重新计算速率，可能会修改这四台主机。在 BitTorrent 中，这四台主机被称为是 `unchoked`。重要的是，每隔 30 秒，它还会随机选择一个额外的 neighbor 来发送文件块。假如随机选择了主机 Bob。在 BitTorrent 中，Bob 就是`optimistically unchoked`。因为 Alice 正发送数据给 Bob，所以在 Bob 开始传数据给 Alice 时，Alice 可能成为 Bob 最高的四个上传者之一。如果 Bob 给 Alice 发送数据的速率足够快，就会变成 Alice 的四个最高的四传者之一。换句话说，每隔 30 秒，Alice 会随机选择一个新的伙伴进行数据互换。如果两者都对这次数据互换感到满意，它们就将对方变成自己的四个最高的列表之一，然后继续交换数据，直到其中一个找到更好的伙伴。

### 分布式哈希表(DHTs)

许多 P2P 应用和其它的分布式应用的关键部件就是索引（也就是一个简单的数据库），支持搜索和更新操作。当这个数据库是分布式的，主机就可以在它们之间执行内容缓存和复杂的路由查询。由于信息的索引和搜索是这种系统的关键部件，我们现在就了解一个流行的索引和搜索技巧，分布式哈希表(DHTs)。

我们就这样考虑在大量的（可能上百万）主机上创建一个简单的支持简易索引和搜索的分布式数据库。例如，key 可以是社保号码，value 可以是对应的人名；在这个示例中，一个用于示例的 key-value 对是（156-45-7081，Johnny Wu）。或者 key 可以是内容名称（例如，电影名称、唱片名称和软件名称），value 可以是内容所在的 IP 地址；在这个示例中，一个用于示例的 key-value 对是（Led Zeppelin IV，208.17.123.38）。主机通过 key 来查找数据库：如果在数据库里有对应的 key-value 对匹配上了该 key，数据库就向主机返回匹配查询的 key-value 对。主机还可以添加 key-value 对到数据库中。

在 client-server 架构中，要创建这样的数据库是相当直接的，所有的 key-value 对都存储在一个中心服务器中。早期的 P2P 系统，如 Napster 也采用这种中心化的实现。由上百万个连接的主机形成的没有中心化的分布式系统最大的问题就是更有挑战性以及更有趣。在 P2P 系统中，我们想将 key-value 对在所有的主机中分发，因此，每一台主机都只存储所有的 key-value 对的很小一部分。一个天真的 P2P 数据库实现就是随机将这些 key-value 分散到主机中，然后每台主机都维护一份所有主机的 IP 列表。在这种方式中，查询的主机可以发请求到其它所有的主机中，匹配 key 的主机由响应对应的 key-value 对。这种实现完全是不可扩展的，当然，它还需要每台主机都跟踪其它所有的主机（可能有上百万），更糟的是，每次查询都要发送到所有主机。

以下要介绍一种设计 P2P 数据库的优雅方法。为此，先为每个主机分配一个标识符，这个标识符是 [0,2^n-1] 范围内的一个整数。标识符可以由 n 位来表示。我们要求每个 key 也在这个整数范围内。但之前我们看到 key 不一定是整数（例如社保号码和内容名称），为了给这些 key 创建这种范围内的整数，我们需要使用一个 hash 函数为每个 key 生成整数映射。hash 函数是多对一的函数，两个不同的输入可以产生相同的输出，但这个可能性是极小的。假定 hash 函数是对系统中的所有主机都是公开可用的。之后我们说的 key 指的是原始 key 的 hash 值。由于我们使用的是 key 的 hash 值，而不是 key 本身，所以之后我们说的分布式数据库指的是分布式哈希表(DHT)。

现在要考虑的就是在 DHT 中存储 key-value 对的问题。现在核心的问题就是为主机定义了分配 key 的规则。每台主机都有一个整数的标识符，每个 key 也是在同样范围内的整数。一个很自然的实现就是将 key-value 分配到标识符跟 key 最接近的主机中。为了实现这个计划，我们需要定义什么“最接近”。为了方便，将最接近的主机定义为`immediate successor of the key`（key 的直接后继者）。下面来看一个示例，假设 n = 4，则主机和 key 标识符的范围是 [0,15]。再假定在系统中有 8 台主机，它们的标识符是 1, 3, 4, 5, 8, 1, 12 和 15。最后，我们想存储 key-value 对（11, Johnny Wu），那么应该存储在哪台主机呢？用就近原则的话，由于主机 12 是 11 的直接后继者，所以将（11，Johnny Wu）存储在主机 12 中。下面来完善一下就近原则的定义，如果 key 跟其中一台主机的标识符相等，则直接存储；如果 key 比所有的主机标识符都大，则取 2 的模，将 key-value 对存储在最小的标识符对应的主机。

现在假设一个主机 Alice 想添加一个 key-value 对到 DHT 中。在概念上，这是很直接的：首先判断标识符跟 key 最接近的主机；接着发送消息到主机，指示它存储这个 key-value 对。但 Alice 是怎么判断哪台主机是最接近 key 的呢？如果 Alice 在系统中保存了所有的主机（主机 ID 和对应的 IP 地址），就可以在本地判断哪台主机是最接近的。但这种实现要求每台主机都保存 DHT 里的所有主机——这对拥有上百万主机的大型系统完全是不现实的。

##### 环状 DHT

为了解决规模上的难题，现在我们将主机组成成环状。在这种安排中，每个主机都只追踪它的直接后继者。
