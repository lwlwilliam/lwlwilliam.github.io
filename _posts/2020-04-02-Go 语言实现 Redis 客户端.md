---
title: Go 语言实现 Redis 客户端
layout: post
categories: [计算机网络, Go]
keys: Redis, protocol, redis-cli, 计算机网络, Go
---

> 除 Telnet 以及 Go 代码部分之外，其它内容基本翻译自官网

### Redis 通信协议介绍

Redis 客户端使用 RESP(REdis Serialization Protocol) 协议跟 Redis 服务端进行通信。RESP 协议是专门为 Redis 而设计的，当然，它也可以被其他 CS 架构软件项目使用。

RESP 在以下几方面进行了折衷。

*   易于实现
*   解析快速
*   可读的

RESP 可以序列化不同的数据类型，如 integers, strings, arrays 以及一个特别的错误类型 errors。客户端发送到服务端的请求是以字符串数组表示要执行的命令的。

**RESP 协议仅用于 CS 通信。Redis 集群为了在节点间交换数据，所以用的是另一个二进制协议。**

<div style="display:none;">
### 网络层

客户端通过创建端口号为 6379 的 TCP 连接来连接到 Redis 服务端。虽然 RESP 在技术上并没有指定用于 TCP，但在 Redis 的上下中，该协议仅用于 TCP 连接（或因似于 Unix 套接字的面向流的连接）。
</div>

#### 请求-响应模型

Redis 接收由不同参数组成的命令。一旦接收到命令，就会进行处理并将响应发送回客户端。

这可能是最简单的模型，但还有两个例外：

*   Redis 支持管道。所以客户端可以一次性发送多个命令，并等待响应；
*   一旦客户端订阅了 Pub/Sub 频道，协议就会变成一个推协议，也就是说，客户端再也不需要发送发送命令了，因为服务端一旦接收到（客户端订阅的消息）就会自动向客户端发送新消息（客户端订阅了的频道消息）。

除了以上两个例外，Redis 协议就是一个简单的请求-响应协议。

#### RESP 协议说明

RESP 协议最早在 Redis 1.2 中实现，但在 Redis 2.0 中才成为与 Redis 服务端通信的标准方式。

RESP 是序列化协议，支持以下数据类型：Simple Strings, Errors, Integers, Bulk Strings 和 Arrays。

RESP 在 Redis 中作为请求-响应协议用法如下：

*   客户端向 Redis 服务端以 REAP Array 形式发送 Bulk Strings
*   服务端根据命令的实现来响应其中一种 RESP 类型。

在 RESP 中，一些数据的类型取决于第一个字节：

*   Simple String 响应的第一个字节是`+`
*   Errors 响应的第一个字节是`-`
*   Integers 响应的第一个字节是`:`
*   Bulk Strings 响应的第一个字节是`$`
*   Arrays 响应的第一个字节是`*`

除此之外，RESP 也可能使用一个特别的 Bulk Strings 或 Arrays 变体来代表 Null 值。在 RESP 中协议的不同部分使用`\r\n`（CRLF）来结束。

#### RESP Simple Strings

Simple String 编码方式：`+`符号，后面跟着不含 CR 或 LF 字符的字符串，最后以 CRLF（`\r\n`）结束。示例如下：

```
"+OK\r\n"
```

Simple Strings 用来传输非二进制安全字符串。

#### RESP Errors

Errors 跟 Simple Strings 很像，但第一个字符是`-`。示例如下：

```
"-Errors message\r\n"
```

#### RESP Integers

Integers 以`:`开头。示例如下：

```
":1000\r\n"
```

#### RESP Bulk Strings

Bulk Strings 用来表示一个最大为 512MB 的二进制安全的字符串，用以下方式进行编码：

*   `$`字符开头，后面跟着字符中的长度，以 CRLF 结束
*   具体的字符串数据
*   最后的 CRLF

因此，字符串 foobar 编码如下：

```
"$6\r\nfoobar\r\n"
```

空字符串如下：

```
"$0\r\n\r\n"
```

空字符串也叫 Null Bulk Strings。

客户端 API 不应该返回一个空字符串，而应该是 nil 对象。

#### RESP Arrays

客户端以 RESP Arrays 的形式向 Redis 服务端发送命令，同理，Redis 服务端也会用 RESP Arrays 响应客户端。

RESP Arrays 用以下格式发送：

*   `*`作为首字节，后面跟着表示数组元素个数的十进制数，再跟着 CRLF
*   数组元素额外的 RESP 类型

空 Array 表示方式如下：

```
"*0\r\n"
```

又例如，包含两个 RESP Bulk String 元素 foo 和 bar 的数组编码如下：

```
"*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n"
```

可以看到在`*<count>CRLF`部分之后，组成 array 的其他类型仅仅是一个连着一个罢了。例如，由三个整型数据组成的 Array 编码如下：

```
"*3\r\n:1\r\n:2\r\n:3\r\n"
```

Arrays 可以包含多个类型。例如，四个整型和一个 bulk string 组成的列表可以编码如下：

```
*5\r\n:1\r\n:2\r\n:3\r\n:4\r\n$6\r\nfoobar\r\n"
```

#### Arrays 中的 Null 元素

在 Redis 中为了表示元素不存在，使用的是 Null，而不是空字符串。例如：

```
*3\r\n
$3\r\n
foo\r\n
$-1\r\n
$3\r\n
bar\r\n
```

第二个元素是 Null，客户端库应该用类似于以下的形式返回：

```
["foo",nil,"bar"]
```


#### 使用 Telnet 向 Redis 服务器发送命令

熟悉了 RESP 序列化格式之后，实现 Redis 客户端库就比较容易了。

下面指定客户端和服务端的两个交互：

*   客户端向 Redis 服务端发送只由 Bulk Strings 组成的 RESP Array 
*   Redis 服务端可以响应客户端任何有效的 RESP 数据类型

以下是一个简单的示例，默认 redis 在运行。

```bash
$ telnet 127.0.0.1 6379
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.

*3
$3
SET
$5
hello
$5
world
+OK

*2
$3
GET
$5
hello
$5
world

*2
$3
GET
$5
hahah
$-1

PING
+PONG
```

以上是四条命令，第一条请求服务端设置 hello 的值为 world，服务端响应`+OK\r\n`，类型是 Simple Strings；第二条请求获取刚才设置的 hello 的值，服务端响应`$5\r\nworld\r\n`，类型是 Bulk Strings；第三条请求获取不存在的 hahah，服务端响应`$-1\r\n`，也就是 Null。最后一条是特别的。

### Go 语言实现 Redis 客户端

```go
// redis/redis.go
package redis

import (
	"fmt"
	"log"
	"net"
	"time"
)

type Client struct {
	Conn net.Conn
	Host string
	Port string
}

func (c *Client) Connect() {
	if c.Host == "" || c.Port == "" {
		c.Host = "127.0.0.1"
		c.Port = "6379"
	}

	conn, err := net.DialTimeout("tcp", c.Host+":"+c.Port, 10*time.Second)
	fatal(err)
	c.Conn = conn
}

func (c *Client) Set(name, value string) (string, error) {
	action := "set"
	cmd := assemble([]string{
		action,
		name,
		value,
	})

	return c.send(action, cmd)
}

func (c *Client) Get(name string) (string, error) {
	action := "get"
	cmd := assemble([]string{
		action,
		name,
	})

	return c.send(action, cmd)
}

func assemble(cmd []string) string {
	cmdstr := fmt.Sprintf("*%d\r\n", len(cmd))

	for _, v := range cmd {
		cmdstr += fmt.Sprintf("$%d\r\n%s\r\n", len(v), v)
	}

	fmt.Printf("assemble: %q\n", cmdstr)

	return cmdstr
}

func (c *Client) send(logAction, cmd string) (string, error) {
	_, err := c.Conn.Write([]byte(cmd))
	if err != nil {
		log.Println(logAction, ":", err)
		return "", err
	}

	return c.response(), nil
}

func (c *Client) response() string {
	buf := make([]byte, 1024)
	n, _ := c.Conn.Read(buf)
	return string(buf[:n])
}

func fatal(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
```

使用示例

```go
package main

import (
	"fmt"
	"redis"
)

func main() {
	r := redis.Client{}

	r.Connect()

	data, _ := r.Set("gogogo", "gogogo value")
	fmt.Printf("set response: %q\n", data)

	data, _ = r.Get("gogogo")
	fmt.Printf("get response: %q\n", data)
}
```

由于本文只是为了简单说明 Go 实现 Redis 客户端的原理，所以仅仅实现了部分功能，代码也比较简陋。如果有兴趣，可以继续深入学习，本文就介绍到这。
