---
title: Makefile 是什么？它是如何工作的？
layout: post
category: [编译原理]
keywords: make, makefile
---

如果想要在某些文件更新时执行或更新任务，`make`工具会令这个过程变得很方便。`make`工具需要`Makefile`(或`makefile`)文件来定义要执行的一系列任务。你可能已经使用过`make`将源码编译为程序。大部分开源项目都使用`make`来编译为二进制的可执行程序，编译后的程序可以使用`make install`进行安装。

本文将使用一些基本和高级的示例来对`make`和`makefile`进行探索。在这之前，先确保`make`已经安装好了。

### 基础示例

下面我们在终端上以经典的打印"Hello World"作为开始。创建一个空目录 myproject，目录里创建一个包含以下内容的`makefile`文件：

```
say_hello:
    echo "Hello World"
```

现在在 myproject 目录里通过`make`命令执行这个文件：

```
$ make
echo "Hello World"
Hello World
```

在上例中，say_hello 类似于其它编程语言中的函数名。这叫做 *target*。*prerequisites* 或 *dependencies* 就在 *target* 之后。为了简单起见，在该例中我们没有定义 *prerequisites*。命令 **echo "Hello World"** 被称为 *recipe* ，*recipe* 使用 *prerequisites* 来创建一个 *target*。*target*，*prerequisites* 和 *recipes* 一起组成了 *rule*。

总而言之，下面是一个典型的 *rule* 语法：

```
target: prerequisites
<TAB> recipe
```

例如，一个依赖 *prerequisites*（源码）的二进制 *target* 。另一方面，一个 *prerequisite* 也可以是一个依赖其它 *dependencies* 的 *target*：

```
final_target: sub_target final_target.c
    Recipe_to_create_final_target
    
sub_target: sub_target.c
    Recipe_to_create_sub_target
```

*target* 并不非得是一个文件，它可以仅仅是 *recipe* 的一个名字，正如我们的示例一样。我们称这种为 *phony targets（`注：伪目标`）*。

回到我们上面的示例，当`make`执行后，完整的命令 **echo "Hello World"** 就会紧接着实际的命令后显示。我们通常不希望这样。为了抑制实际的命令，需要在 **echo** 之前添加 **@**：

```
say_hello:
    @echo "Hello World"
```

现在尝试再次运行`make`。输出应该只显示如下内容：

```
$ make
Hello World
```

让我们添加更多 *phony target* 到`Makefile`中：**generate** 和 **clean**：

```
say_hello:
    @echo "Hello World"

generate:
    @echo "Creating empty text files..."
    touch file-{1..10}.txt
    
clean:
    @echo "Cleaning up..."
    rm *.txt
```

如果我们现在尝试运行`make`，只有 **say_hello** 会被执行。这是因为`makefile`中只有第一个 *target* 是默认的 *target*。通常这被称为 *default goal*，这就是你会在大部分项目都看到 **all** 作为第一个 *target* 的原因。**all** 的责任就是调用其它 *target*。我们也可以通过 *phony target* **.DEFAULT_GOAL** 来修改这个默认行为。

让我们在`makefile`文件开头加上以下内容：

```
.DEFAULT_GOAL := generate
```

这样在运行时就会以 **generate** 作为默认 *target*：

```
$ make
Creating empty text files...
touch file-{1..10}.txt
```

正如名字暗示的意思一样，*phony target* **.DEFAULT_GOAL** 一次只能运行一个 *target*。这就是大部分`makefile`都需要包含 **all** 作为调用其它 *target* 的 *target* 的原因。

让我们使用 *phony target* **all** 并把 **.DEFAULT_GOAL** 删除：

```
all: say_hello generate

say_hello:
    @echo "Hello World"
    
generate:
    @echo "Creating empty text files..."
    touch file-{1..10}.txt
    
clean:
    @echo "Cleaning up..."
    rm *.txt
```

在运行`make`之前，先添加另一个特殊的 *phony target*，**.PHONY**，这是用来定义所有非文件的 *target*。`make`在运行它的 *recipe* 时就不用管它是不是文件或者它上次的修改时间了。这是一个完整的`makefile`：

```
.PHONY: all say_hello generate clean

all: say_hello generate

say_hello:
    @echo "Hello World"
    
generate:
    @echo "Creating empty text files..."
   
clean:
    @echo "Cleaning up..."
    rm *.txt
```

`make`会调用 **say_hello** 和 **generate**：

```
$ make
Hello World
Creating empty text files...
touch file-{1..10}.txt
```

在 **all** 中不调用 **clean** 或者不把 **clean** 放在第一个 *target* 中是一个很好的做法。**clean** 应该手动调用，在调用时作为`make`的第一个参数：

```
$ make clean
Cleaning up...
rm *.txt
```

现在你应该了解一个基本的`makefile`是如何工作以及如何写了个简单的`makefile`了，接下来看了下相对高级的示例。

> 原文：[https://opensource.com/article/18/8/what-how-makefile](https://opensource.com/article/18/8/what-how-makefile)
