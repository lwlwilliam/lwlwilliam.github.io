---
title: 浮点数表示
layout: post
categories: [计算机原理]
keywords: 浮点数
---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>

根据国际标准 IEEE 754，任意一个二进制小数 V 可以表示成以下形式：

![WX20190401-121514.png](/assets/images/2019/0401/WX20190401-121514.png)

1.  $$(-1)^s$$ 表示符号位，当 s 为 0 时，V 为正数；当 s 为 1 时，V 为负数；
2.  M 表示有效数字，值范围为 [1, 2) 之间的实数；
3.  $$2^E$$ 表示指数位，E 可为负数；

对于 32 位浮点数，最高 1 位是符号位 s，接着是 8 位指数 E，剩下 23 位是有效数字 M；对于 64 位浮点数，最高 1 位是符号位 s，接着是 11 位指数 E，剩下 52 位是有效数字 M。

以下是一段提取 32 位浮点数所有位的小程序：

```c
#include <stdio.h>
#include <string.h>

int main() {
    float data;
    unsigned long buff;
    int i;
    char s[35];

    // 将 0.25 以单精度浮点数的形式存储在变量 data 中
    data = (float)0.25;	// 可以把 0.25 改为 0.1 看看

    // 把数据复制到 4 字节长度的整数变量 buff 中逐个提取出每一位
    memcpy(&buff, &data, 4);

    // 逐一提取出每一位
    for (i = 33; i >= 0; i --) {
        if (i == 1 || i == 10) {
            // 加入破折号来区分符号部分、指数部分和尾数部分
            s[i] = '-';
        } else {
             // 为各个字节赋值 '0' 或 '1'
             if (buff % 2 == 1) {
                s[i] = '1';
             } else {
                s[i] = '0';
             }
             buff /= 2;
        }
    }
    s[34] = '\0';

    printf("%s\n", s);
}
```

以上程序在`data = (float)0.25`时，结果为`0-01111101-00000000000000000000000`。十进制的`0.25`相当于二进制的`0.01`，即为`$$1.0*2^{-2}$$`因此，符号位 s 为`0`，指数位 E 为`-2`，有效数字 M 为`1.0`。

因此以上程序的结果中符号位 s 表示为二进制格式就是`0`；而有效数字 M 由于是范围是`[1,2)`，默认整数为 1，只将小数位保存到计算机中，所以`1.0`保存的结果是`00000000000000000000000`；最后指数位 E 是一个无符号整数，但是在科学计数法中指数是可以为负数的，这意味着需要对指数位进行处理，**在 IEEE 754 中规定，E 的真实值必须再减去一个中间数，对于 8 位的 E，这个中间数是 127，对于 11 位的 E，这个中间数是 1023**，所以以上程序中的 E 为`125 - 127 = -2`，`125` 转为二进制表示即为`01111101`。