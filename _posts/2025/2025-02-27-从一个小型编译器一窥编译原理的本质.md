---
title: 从一个小型编译器一窥编译原理的本质
layout: post
categories: [编译原理]
keywords: 编译原理
---

```php
<?php

// ------------------------
// Lexer（手工实现字符分析）
// ------------------------
class Lexer
{
    private $input;
    private $pos = 0;
    private $currentChar;

    public function __construct($input)
    {
        $this->input = $input;
        $this->currentChar = $input[0] ?? null;
    }

    private function advance()
    {
        $this->pos++;
        $this->currentChar = $this->input[$this->pos] ?? null;
    }

    private function skipWhitespace()
    {
        while ($this->currentChar !== null && ctype_space($this->currentChar)) {
            $this->advance();
        }
    }

    private function integer()
    {
        $result = '';
        while ($this->currentChar !== null && ctype_digit($this->currentChar)) {
            $result .= $this->currentChar;
            $this->advance();
        }
        return (int)$result;
    }

    private function identifier()
    {
        $result = '';
        while ($this->currentChar !== null && (ctype_alnum($this->currentChar) || $this->currentChar === '_')) {
            $result .= $this->currentChar;
            $this->advance();
        }
        return $result;
    }

    public function getNextToken()
    {
        while ($this->currentChar !== null) {
            if (ctype_space($this->currentChar)) {
                $this->skipWhitespace();
                continue;
            }

            if (ctype_digit($this->currentChar)) {
                return ['type' => 'INTEGER', 'value' => $this->integer()];
            }

            if (ctype_alpha($this->currentChar)) {
                $id = $this->identifier();
                if (strtoupper($id) === 'PRINT') {
                    return ['type' => 'PRINT', 'value' => $id];
                }
                return ['type' => 'ID', 'value' => $id];
            }

            switch ($this->currentChar) {
                case '=':
                    $this->advance();
                    return ['type' => 'ASSIGN', 'value' => '='];
                case '+':
                    $this->advance();
                    return ['type' => 'PLUS', 'value' => '+'];
                case '-':
                    $this->advance();
                    return ['type' => 'MINUS', 'value' => '-'];
                case '*':
                    $this->advance();
                    return ['type' => 'MUL', 'value' => '*'];
                case '/':
                    $this->advance();
                    return ['type' => 'DIV', 'value' => '/'];
                case ';':
                    $this->advance();
                    return ['type' => 'SEMI', 'value' => ';'];
                case '(':
                    $this->advance();
                    return ['type' => 'LPAREN', 'value' => '('];
                case ')':
                    $this->advance();
                    return ['type' => 'RPAREN', 'value' => ')'];
                default:
                    throw new Exception("Invalid character: " . $this->currentChar);
            }
        }

        return ['type' => 'EOF', 'value' => null];
    }
}

// ------------------------
// Parser（递归下降解析）
// ------------------------
class Parser
{
    private $lexer;
    private $currentToken;

    public function __construct($lexer)
    {
        $this->lexer = $lexer;
        $this->currentToken = $lexer->getNextToken();
    }

    private function eat($tokenType)
    {
        if ($this->currentToken['type'] === $tokenType) {
            $this->currentToken = $this->lexer->getNextToken();
        } else {
            throw new Exception("Syntax error: expected $tokenType");
        }
    }

    private function factor()
    {
        $token = $this->currentToken;

        if ($token['type'] === 'INTEGER') {
            $this->eat('INTEGER');
            return ['type' => 'NumberLiteral', 'value' => $token['value']];
        }

        if ($token['type'] === 'ID') {
            $this->eat('ID');
            return ['type' => 'Variable', 'name' => $token['value']];
        }

        if ($token['type'] === 'LPAREN') {
            $this->eat('LPAREN');
            $node = $this->expr();
            $this->eat('RPAREN');
            return $node;
        }

        throw new Exception("Unexpected factor: " . $token['type']);
    }

    private function term()
    {
        $node = $this->factor();

        while (in_array($this->currentToken['type'], ['MUL', 'DIV'])) {
            $token = $this->currentToken;
            $this->eat($token['type']);
            $node = [
                'type' => 'BinaryOp',
                'left' => $node,
                'op' => $token['value'],
                'right' => $this->factor()
            ];
        }

        return $node;
    }

    private function expr()
    {
        $node = $this->term();

        while (in_array($this->currentToken['type'], ['PLUS', 'MINUS'])) {
            $token = $this->currentToken;
            $this->eat($token['type']);
            $node = [
                'type' => 'BinaryOp',
                'left' => $node,
                'op' => $token['value'],
                'right' => $this->term()
            ];
        }

        return $node;
    }

    private function statement()
    {
        if ($this->currentToken['type'] === 'PRINT') {
            $this->eat('PRINT');
            $expr = $this->expr();
            $this->eat('SEMI');
            return ['type' => 'PrintStatement', 'expr' => $expr];
        }

        if ($this->currentToken['type'] === 'ID') {
            $varName = $this->currentToken['value'];
            $this->eat('ID');
            $this->eat('ASSIGN');
            $expr = $this->expr();
            $this->eat('SEMI');
            return ['type' => 'Assignment', 'name' => $varName, 'expr' => $expr];
        }

        throw new Exception("Invalid statement");
    }

    public function parse()
    {
        $statements = [];
        while ($this->currentToken['type'] !== 'EOF') {
            $statements[] = $this->statement();
        }
        return ['type' => 'Program', 'body' => $statements];
    }
}

// ------------------------
// 代码生成器
// ------------------------
class CodeGenerator
{
    private $ast;
    private $instructions = [];
    private $varIndex = 0;
    private $varMap = [];

    public function __construct($ast)
    {
        $this->ast = $ast;
    }

    private function generateExpr($node)
    {
        switch ($node['type']) {
            case 'NumberLiteral':
                $this->instructions[] = ['op' => 'PUSH', 'value' => $node['value']];
                break;
            case 'Variable':
                if (!isset($this->varMap[$node['name']])) {
                    $this->varMap[$node['name']] = $this->varIndex++;
                }
                $this->instructions[] = ['op' => 'LOAD', 'address' => $this->varMap[$node['name']]];
                break;
            case 'BinaryOp':
                $this->generateExpr($node['left']);
                $this->generateExpr($node['right']);
                switch ($node['op']) {
                    case '+':
                        $this->instructions[] = ['op' => 'ADD'];
                        break;
                    case '-':
                        $this->instructions[] = ['op' => 'SUB'];
                        break;
                    case '*':
                        $this->instructions[] = ['op' => 'MUL'];
                        break;
                    case '/':
                        $this->instructions[] = ['op' => 'DIV'];
                        break;
                }
                break;
        }
    }

    public function generate()
    {
        foreach ($this->ast['body'] as $stmt) {
            switch ($stmt['type']) {
                case 'PrintStatement':
                    $this->generateExpr($stmt['expr']);
                    $this->instructions[] = ['op' => 'PRINT'];
                    break;
                case 'Assignment':
                    $this->generateExpr($stmt['expr']);
                    if (!isset($this->varMap[$stmt['name']])) {
                        $this->varMap[$stmt['name']] = $this->varIndex++;
                    }
                    $this->instructions[] = ['op' => 'STORE', 'address' => $this->varMap[$stmt['name']]];
                    break;
            }
        }
        return $this->instructions;
    }
}

// ------------------------
// 虚拟机
// ------------------------
class VM
{
    private $code;
    private $stack = [];
    private $memory = [];
    private $pc = 0;

    public function __construct($code)
    {
        $this->code = $code;
    }

    public function run()
    {
        while ($this->pc < count($this->code)) {
            $instr = $this->code[$this->pc++];
            switch ($instr['op']) {
                case 'PUSH':
                    $this->stack[] = $instr['value'];
                    break;
                case 'LOAD':
                    $this->stack[] = $this->memory[$instr['address']] ?? 0;
                    break;
                case 'STORE':
                    $value = array_pop($this->stack);
                    $this->memory[$instr['address']] = $value;
                    break;
                case 'ADD':
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = $a + $b;
                    break;
                case 'SUB':
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = $a - $b;
                    break;
                case 'MUL':
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = $a * $b;
                    break;
                case 'DIV':
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = $a / $b;
                    break;
                case 'PRINT':
                    echo array_pop($this->stack) . PHP_EOL;
                    break;
            }
        }
    }
}

// ------------------------
// 测试用例
// ------------------------
$input = <<<CODE
print (3 + 5) * 2;
a = 10 - 2;
print a * 3;
CODE;

try {
    // 词法分析
    $lexer = new Lexer($input);

    // 语法分析生成AST
    $parser = new Parser($lexer);
    $ast = $parser->parse();

    // 生成中间代码
    $generator = new CodeGenerator($ast);
    $code = $generator->generate();

    // 虚拟机执行
    $vm = new VM($code);
    $vm->run();

} catch (Exception $e) {
    echo "Error: " . $e->getMessage();
}
```