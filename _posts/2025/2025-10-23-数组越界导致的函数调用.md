---
title: 数组越界导致的函数调用
layout: post
categories: [编译原理]
keywords: 编译原理
---

`C`语言中数组越界是未定义行为，因此以下代码在不同的编译器或者不同版本的同一编译器行为是不可预测的。在`gcc`某些版本中，以下代码会出现有意思的行为。

```cpp
// demo.c
#include <stdio.h>
#include <stdlib.h>

void jmp() {
    printf("Hello jmp\n");
    exit(1);
}

void func() {
    long arr[2];
    arr[3] = (long)jmp;
}

int main() {
    func();
    printf("Hello main\n");
    return 0;
}
```

编译使用的`gcc`信息如下：

```bash
$ gcc -v
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/12/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:amdgcn-amdhsa
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Debian 12.2.0-14' --with-bugurl=file:///usr/share/doc/gcc-12/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++,m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-12 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-12-bTRWOB/gcc-12-12.2.0/debian/tmp-nvptx/usr,amdgcn-amdhsa=/build/gcc-12-bTRWOB/gcc-12-12.2.0/debian/tmp-gcn/usr --enable-offload-defaulted --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
Supported LTO compression algorithms: zlib zstd
gcc version 12.2.0 (Debian 12.2.0-14)
```

行为如下：

```bash
$ gcc demo.c
$ ./a.out
Hello jmp
$ echo $?
1
```

这就有点意思了，看起来`jmp`函数被执行了，而`printf("Hello main\n");`语句却没有一点效果。通过汇编看看到底发生了什么事情，这里推荐一个网站 [https://godbolt.org](https://godbolt.org)。

```assembly
_Z3jmpv:
 push   rbp
 mov    rbp,rsp
 mov    edi,0x402004
 call   401040 <puts@plt>
 mov    edi,0x1
 call   401030 <exit@plt>
_Z4funcv:
 push   rbp
 mov    rbp,rsp
 mov    eax,0x401136
 mov    QWORD PTR [rbp+0x8],rax
 nop
 pop    rbp
 ret
main:
 push   rbp
 mov    rbp,rsp
 call   40114e <_Z4funcv>
 mov    edi,0x40200e
 call   401040 <puts@plt>
 mov    eax,0x0
 pop    rbp
 ret
```

`main`函数通过`call   40114e <_Z4funcv>`调用`func`函数时会把`mov    edi,0x40200e`所在的内存地址压栈，然后跳转到`func`所在地址，`push   rbp`之后，`rsp`的地址是`[rbp]`，而函数的返回地址则为`[rbp+0x8]`，而栈是由高地址往低地址增长的。在`long arr[2]`数组中，内存地址如下所示：

```
[rbp+0x8]       -> arr[3]
[rbp]           -> arr[2]

[rbp-0x8]       -> arr[1]
[rbp-0x10]      -> arr[0]
```

因此`arr[3]`的地址跟函数返回地址一致，当它被赋值为`(long)jmp`时，`func`函数退出后就会跳转到`jmp`函数，就会出现上面看起来很奇怪的执行结果`Hello jmp`。

原理理解了，那就可以自己修改一下汇编，例如在`_Z4funcv`的`push   rbp`之后再加一个`push   rbp`，然后将`mov    QWORD PTR [rbp+0x8],rax`改成`mov    QWORD PTR [rbp+0x10],rax`，最后把在`pop    rbp`再重复一次`pop    rbp`，看看结果是否一致。

```assembly
_Z3jmpv:
 push   rbp
 mov    rbp,rsp
 mov    edi,0x402004
 call   401040 <puts@plt>
 mov    edi,0x1
 call   401030 <exit@plt>
_Z4funcv:
 push   rbp
 push   rbp
 mov    rbp,rsp
 mov    eax,0x401136
 mov    QWORD PTR [rbp+0x10],rax
 nop
 pop    rbp
 pop    rbp
 ret
main:
 push   rbp
 mov    rbp,rsp
 call   40114e <_Z4funcv>
 mov    edi,0x40200e
 call   401040 <puts@plt>
 mov    eax,0x0
 pop    rbp
 ret
```
