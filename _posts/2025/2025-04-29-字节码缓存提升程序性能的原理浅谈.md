---
title: 字节码缓存提升程序性能的原理浅谈
layout: post
categories: [ 编译原理 ]
keywords: 编译原理
---

像`Java`这类语言，编译器会把代码预先编译为字节码，`JVM`直接解释执行这些字节码，程序就可以运行起来了。`PHP`使用者在性能优化时可能也会遇到`OPcache`这个名词，所谓`OPcache`其实就是`opcode`的`cache`，`opcode`其实类似于字节码，虽然本质上有点差异，但可以类比为同一种事物。

`PHP`在开启`OPcache`扩展后，传统的`PHP`程序运行速度会提升很多，究其原因，就是`OPcache`扩展会将代码编译中间结果`opcode`进行缓存，而`php-fpm`的运行模式又是每次请求都会重新解释代码，也就是每次请求都会省略了前面的编译过程，所以单位时间内就能节省很多实际运行时间。与之相反，`php-cli`运行模式下的程序，`OPcache`对其起到的作用不大，因为`php-cli`下，程序由于常驻内存而只需要解释一次执行多次。

以下是一个用`PHP`写的小型编译器，其中`Lexer`、`Parser`、`CodeGenerator`部分已经被我剔除，因为生成字节码之后，这些部分对程序的运行没有实质的作用了，此时仅需要一个执行字节码的`VM`。为了便于理解，我将生成的字节码做成`JSON`格式，实际执行时，只需要`JSON`解码，`PHP`做的`VM`逐个执行即可。

```php
<?php

class OpCode
{
    const ICONST = 'ICONST'; // push 整型常量
    const LOAD = 'LOAD'; // 加载变量
    const STORE = 'STORE'; // 存储变量
    const PRINT = 'PRINT'; // 打印栈顶
    const ADD = 'ADD';
    const SUB = 'SUB';
    const MUL = 'MUL';
    const DIV = 'DIV';
    const LT = 'LT';
    const GT = 'GT';
    const EQ = 'EQ';
    const NE = 'NE';
    const LE = 'LE';
    const GE = 'GE';
    const AND = 'AND';
    const OR = 'OR';
    const NOT = 'NOT';
    const JMP = 'JMP';
    const JMPF = 'JMPF'; // 条件跳转：如果条件为假
    const CALL = 'CALL';
    const RET = 'RET';
    const POP = 'POP';
}

class VirtualMachine
{
    private array $instructions;
    private array $functions;
    private int $ip;         // 指令指针
    private array $stack;      // 数据栈
    private array $globals;    // 全局（或局部）变量表
    private array $callStack;  // 保存调用现场（返回地址和变量环境）

    public function __construct($instructions, $functions)
    {
        $this->instructions = $instructions;
        $this->functions = $functions;
        $this->ip = 0;
        $this->stack = [];
        $this->globals = [];
        $this->callStack = [];
    }

    /**
     * @throws Exception
     */
    public function run()
    {
        while ($this->ip < count($this->instructions)) {
            $instr = $this->instructions[$this->ip];
            switch ($instr['op']) {
                case OpCode::ICONST: // 入栈常量
                    $this->stack[] = $instr['operand'];
                    $this->ip++;
                    break;
                case OpCode::LOAD: // 从变量区中取出变量值，入栈
                    $var = $instr['operand'];
                    $this->stack[] = $this->globals[$var] ?? 0;
                    $this->ip++;
                    break;
                case OpCode::STORE: // 将值保存到全局变量中。类似于 a = 5 => $globals = ['a' => 5]
                    $var = $instr['operand'];
                    $value = array_pop($this->stack);
                    $this->globals[$var] = $value;
                    $this->ip++;
                    break;
                case OpCode::PRINT: // 出栈一个值，echo 出来
                    $value = array_pop($this->stack);
                    echo $value . "\n";
                    $this->ip++;
                    break;
                case OpCode::ADD: // 出栈两个值，相加后将结果入栈
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = $a + $b;
                    $this->ip++;
                    break;
                case OpCode::SUB: // 出栈两个值，相减后将结果入栈
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = $a - $b;
                    $this->ip++;
                    break;
                case OpCode::MUL: // 出栈两个值，相乘后将结果入栈
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = $a * $b;
                    $this->ip++;
                    break;
                case OpCode::DIV: // 出栈两个值，相除后将结果入栈
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = intval($a / $b);
                    $this->ip++;
                    break;
                case OpCode::LT: // 出栈两个值，比较后将结果入栈
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = ($a < $b) ? 1 : 0;
                    $this->ip++;
                    break;
                case OpCode::GT: // 出栈两个值，比较后将结果入栈
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = ($a > $b) ? 1 : 0;
                    $this->ip++;
                    break;
                case OpCode::EQ: // 出栈两个值，比较后将结果入栈
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = ($a == $b) ? 1 : 0;
                    $this->ip++;
                    break;
                case OpCode::NE: // 出栈两个值，比较后将结果入栈
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = ($a != $b) ? 1 : 0;
                    $this->ip++;
                    break;
                case OpCode::LE: // 出栈两个值，比较后将结果入栈
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = ($a <= $b) ? 1 : 0;
                    $this->ip++;
                    break;
                case OpCode::GE: // 出栈两个值，比较后将结果入栈
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = ($a >= $b) ? 1 : 0;
                    $this->ip++;
                    break;
                case OpCode::AND: // 出栈两个值，运行后将结果入栈
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = ($a && $b) ? 1 : 0;
                    $this->ip++;
                    break;
                case OpCode::OR: // 出栈两个值，运行后将结果入栈
                    $b = array_pop($this->stack);
                    $a = array_pop($this->stack);
                    $this->stack[] = ($a || $b) ? 1 : 0;
                    $this->ip++;
                    break;
                case OpCode::NOT: // 出栈两个值，运行后将结果入栈
                    $a = array_pop($this->stack);
                    $this->stack[] = (!$a) ? 1 : 0;
                    $this->ip++;
                    break;
                case OpCode::JMP: // 指针指向 JMP 操作数表示的地址上
                    $this->ip = $instr['operand'];
                    break;
                case OpCode::JMPF: // 出栈一个值，如果该值的相当于 false，则指针指向 JMPF 操作数表示的地址上，否则指针正常递增
                    $cond = array_pop($this->stack);
                    if (!$cond) {
                        $this->ip = $instr['operand'];
                    } else {
                        $this->ip++;
                    }
                    break;
                case OpCode::CALL:
                    $funcInfo = $instr['operand'];
                    $funcName = $funcInfo['name'];
                    $argc = $funcInfo['argc'];
                    if (!isset($this->functions[$funcName])) {
                        throw new Exception("未定义函数: " . $funcName);
                    }
                    $fn = $this->functions[$funcName];
                    // 保存当前返回地址和变量环境
                    $this->callStack[] = [$this->ip + 1, $this->globals];
                    // 弹出参数并传给函数
                    $args = [];
                    for ($i = 0; $i < $argc; $i++) {
                        array_unshift($args, array_pop($this->stack));
                    }
                    // 建立新的局部变量表，绑定参数
                    $this->globals = [];
                    $params = $fn['params'];
                    for ($i = 0; $i < count($params); $i++) {
                        $this->globals[$params[$i]] = $args[$i] ?? 0;
                    }
                    $this->ip = $fn['entry'];
                    break;
                case OpCode::RET:
                    $retValue = array_pop($this->stack);
                    if (empty($this->callStack)) {
                        // 程序结束
                        return $retValue;
                    }

                    list($this->ip, $prevGlobals) = array_pop($this->callStack);
                    $this->globals = $prevGlobals;
                    $this->stack[] = $retValue;
                    break;
                case OpCode::POP: // 仅仅出栈一个值，指针递增
                    array_pop($this->stack);
                    $this->ip++;
                    break;
                default:
                    throw new Exception("未知的操作码: " . $instr['op']);
            }
        }
    }
}

$instructions = '[{"op":"ICONST","operand":1},{"op":"ICONST","operand":2},{"op":"ICONST","operand":3},{"op":"MUL"},{"op":"ADD"},{"op":"PRINT"},{"op":"ICONST","operand":1},{"op":"ICONST","operand":2},{"op":"ICONST","operand":3},{"op":"ICONST","operand":4},{"op":"ADD"},{"op":"MUL"},{"op":"ADD"},{"op":"PRINT"},{"op":"ICONST","operand":10},{"op":"STORE","operand":"a"},{"op":"POP"},{"op":"ICONST","operand":2},{"op":"LOAD","operand":"a"},{"op":"ICONST","operand":10},{"op":"ADD"},{"op":"MUL"},{"op":"PRINT"},{"op":"LOAD","operand":"a"},{"op":"ICONST","operand":0},{"op":"GT"},{"op":"JMPF","operand":45},{"op":"LOAD","operand":"a"},{"op":"PRINT"},{"op":"LOAD","operand":"a"},{"op":"ICONST","operand":1},{"op":"EQ"},{"op":"JMPF","operand":39},{"op":"LOAD","operand":"a"},{"op":"ICONST","operand":11},{"op":"SUB"},{"op":"STORE","operand":"a"},{"op":"POP"},{"op":"JMP","operand":44},{"op":"LOAD","operand":"a"},{"op":"ICONST","operand":1},{"op":"SUB"},{"op":"STORE","operand":"a"},{"op":"POP"},{"op":"JMP","operand":23},{"op":"LOAD","operand":"a"},{"op":"PRINT"},{"op":"ICONST","operand":5},{"op":"CALL","operand":{"name":"factorial","argc":1}},{"op":"PRINT"},{"op":"ICONST","operand":10},{"op":"STORE","operand":"b"},{"op":"POP"},{"op":"ICONST","operand":10},{"op":"LOAD","operand":"b"},{"op":"CALL","operand":{"name":"sum","argc":2}},{"op":"PRINT"},{"op":"JMP","operand":80},{"op":"LOAD","operand":"n"},{"op":"ICONST","operand":0},{"op":"EQ"},{"op":"JMPF","operand":65},{"op":"ICONST","operand":1},{"op":"RET"},{"op":"JMP","operand":72},{"op":"LOAD","operand":"n"},{"op":"LOAD","operand":"n"},{"op":"ICONST","operand":1},{"op":"SUB"},{"op":"CALL","operand":{"name":"factorial","argc":1}},{"op":"MUL"},{"op":"RET"},{"op":"RET"},{"op":"ICONST","operand":666666},{"op":"PRINT"},{"op":"LOAD","operand":"a"},{"op":"LOAD","operand":"b"},{"op":"ADD"},{"op":"RET"},{"op":"RET"}]';
$functions = '{"factorial":{"params":["n"],"entry":58},"sum":{"params":["a","b"],"entry":73}}';

$vm = new VirtualMachine(json_decode($instructions, true), json_decode($functions, true));
$vm->run();
```

以上字节码表示的代码如下所示：

```php
$source = <<<'EOF'
print(1 + 2 * 3);
print(1 + 2 * (3 + 4));

a = 10;

print(2 * (a + 10));

while(a > 0) {
    print(a);
    if (a == 1) {
        a = a - 11; 
    } else {
        a = a - 1;
    }
}
print(a);

function factorial(n) {
    if(n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

print(factorial(5));

function sum(a, b) {
    print(666666);
    return a + b;
}

b = 10;
print(sum(10, b));
EOF;
```

输出：

```
7
15
40
10
9
8
7
6
5
4
3
2
1
-10
120
666666
20
```